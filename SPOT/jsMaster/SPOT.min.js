// Add altitude to GT_WGS84
GT_WGS84.prototype.altitude=null;

// Add radian conversion to GT_WGS84
GT_WGS84.prototype.getRadians=function()
{
	var deg2rad=function(degrees) { return degrees*Math.PI/180; }

	var radians=
	{
		latitude  : deg2rad(this.latitude ),
	 	longitude : deg2rad(this.longitude)
	};
	return radians;
}

// Add distance calculation function to GT_WGS84
GT_WGS84.prototype.getDistance=function(that)
{
	var earthRadius=6378.137; // km

	//Get corrected radius taking altitude into account
	var radius=function(wgs84)
	{
		return (wgs84.altitude ? earthRadius : earthRadius+wgs84.altitude)
	}

	var  here = this.getRadians();
	var there = that.getRadians();

	var a =
		Math.cos( here.latitude) *
		Math.cos(there.latitude) * 
		Math.pow(Math.sin((there.longitude-here.longitude)/2),2) +
		Math.pow(Math.sin((there.latitude -here.latitude )/2),2) ;

	var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

	// Use average radius
	return (c * (radius(this)+radius(that))/2);
}

// Add heading calculation (of that from this) to GT_WGS84 objects
GT_WGS84.prototype.getHeading=function(that)
{
	var  here = this.getRadians();
	var there = that.getRadians();

	var hdg = Math.atan2(
		Math.sin(there.longitude-here.longitude) * Math.cos(here.latitude) ,
		Math.cos (here.latitude) * Math.sin(there.latitude) -
		Math.sin (here.latitude) * Math.cos(there.latitude) *
		Math.cos(there.longitude-here.longitude));

	// Convert back to degrees
	// 0->360, rather than -180->+180
	hdg*=180/Math.PI;
	if(hdg<0)
		hdg+=360;

	return hdg;
}

// Create new TRACKER
// Note that we must have one message, so we start the array
function SPOT_TRACKER(message)
{
	this.id=message.messengerId;
	this.name=message.messengerName;
	this.type=message.modelId;
	this.message=new Array();
	this.message.push(new SPOT_MESSAGE(message));
}

// SPOT_MESSAGE represents a single SPOT message
// It inherits from GT_WGS84 to give geo (& OSGB) functionality
function SPOT_MESSAGE(message)
{
	this.id=message.id;
	this.type=message.messageType;
	this.time=new Date(message.unixTime * 1000);
	this.battery=message.batteryState;
	this.latitude=message.latitude;
	this.longitude=message.longitude;
}
SPOT_MESSAGE.prototype = new GT_WGS84();
SPOT_MESSAGE.prototype.constructor = SPOT_MESSAGE;

function SPOT_FEED(id)
{
	this.id=id;
	this.description="";
	this.name="";
	this.latestMessage  =null;
	this.earliestMessage=null;
	this.lastUpdated    =null;
	this.tracker=new Array();
}

// SPOT_FEEDS is a global variable to allow callbacks
var SPOT_FEEDS=new Object();
SPOT_FEEDS.feed=new Array();
SPOT_FEEDS.json={};

// Update one or more feeds - Default is all
SPOT_FEEDS.update = function(callback, feeds, previous)
{
	if(!feeds)
		feeds = SPOT_FEEDS.feed;

	//for (var ix=0; ix<SPOT_FEEDS.feed.length; ix++)
	for (var ix=0; ix<feeds.length; ix++)
	{
		var url="https://api.findmespot.com/spot-main-web/consumer/rest-api/2.0/public/feed/"+feeds[ix].id+"/message.json";
		if(!feeds[ix].id)
			url="example1.jsonp";

		// Add time filter
		if(!previous && feeds[ix].latestMessage)
			url+="?startDate="
				+ feeds[ix].latestMessage.toJSON().substr(0,19)
				+ "-0000" ;
		if(previous && feeds[ix].earliestMessage)
			url+="?endDate="
				+ feeds[ix].earliestMessage.toJSON().substr(0,19)
				+ "-0000" ;

		console.log(url);
		feeds[ix].lastUpdated=new Date();
		J50Npi.getJSON(url, SPOT_FEEDS.json, function(json)
		{
			var response=json.response.feedMessageResponse;
			var fed = SPOT_FEEDS.getFeed(response.feed.id);
			fed.name = response.feed.name;
			fed.description = response.feed.description;
			for(var ix=response.messages.message.length-1; ix>-1 ; ix--)
			{
				fed.addMessage(response.messages.message[ix]);

				var msgTime = new Date(response.messages.message[ix].unixTime*1000);
				if(!fed.earliestMessage || fed.earliestMessage>msgTime)
					fed.earliestMessage = msgTime;
				if(!fed.latestMessage || fed.latestMessage<msgTime)
					fed.latestMessage = msgTime;
			}
		
			// Now sort the arrays
			fed.tracker.sort(SPOT_FEEDS.sortName);
			for(var ix=0; ix<fed.tracker.length; ix++)
				fed.tracker[ix].message.sort(function (a,b)
				{
					return (b.time - a.time);
				});

			// And finally do another callback
			if(callback)
				callback(fed);
		}
		);
	}
}

// Alphabetic sort on name
SPOT_FEEDS.sortName = function(a,b)
{
	if(a.name>b.name)
		return 1;
	if(a.name<b.name)
		return -1;
	return 0;
}
// Get the feed object based on the id
SPOT_FEEDS.getFeed = function(feedId)
{
	for(var ix=0; ix<SPOT_FEEDS.feed.length; ix++)
		if(SPOT_FEEDS.feed[ix].id == feedId)
			return SPOT_FEEDS.feed[ix];
	return null
}

SPOT_FEEDS.addFeed = function(feedId)
{
	if(!feedId)
		feedId=0;
	SPOT_FEEDS.feed.push(new SPOT_FEED(feedId));
	SPOT_FEEDS.feed.sort(SPOT_FEEDS.sortName);
}

// Get SPOT_TRACKER object based on TrackerId
SPOT_FEED.prototype.getTracker = function(id)
{
	for(var ix=0; ix<this.tracker.length; ix++)
	{
		if(this.tracker[ix].id == id)
			return this.tracker[ix];
	}
	return null;
}
SPOT_FEEDS.getTracker = function(id)
{
	for(var ix=0; ix<this.feed.length; ix++)
	{
		var tracker=this.feed[ix].getTracker(id);
		if(tracker)
			return tracker;
	}
	return null;
}

SPOT_FEED.prototype.addMessage = function(message)
{
	var msg=new SPOT_MESSAGE(message);
	// Look to see if we "know" the messenger
	var tracker=this.getTracker(message.messengerId);
	if(!tracker)
		this.tracker.push(new SPOT_TRACKER(message));
	else 
	{
		// Check that we don't already have the message
		for(var ix=0; ix<tracker.message.length; ix++)
			if(tracker.message[ix].id == msg.id)
				return false;

		tracker.message.unshift(msg);
	}
}

// vim: ts=2:sw=2
