// Get URL Parameters
function getURLParameter(name) {
		return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search)||[,""])[1].replace(/\+/g, '%20'))||null
}

// Add altitude to GT_WGS84
GT_WGS84.prototype.altitude=null;

// Add radian conversion to GT_WGS84
GT_WGS84.prototype.getRadians=function()
{
	var deg2rad=function(degrees) { return degrees*Math.PI/180; }

	var radians=
	{
		latitude  : deg2rad(this.latitude ),
	 	longitude : deg2rad(this.longitude)
	};
	return radians;
}

// Add distance calculation function to GT_WGS84
GT_WGS84.prototype.getDistance=function(that)
{
	var earthRadius=6378.137; // km

	//Get corrected radius taking altitude into account
	var radius=function(wgs84)
	{
		return (wgs84.altitude ? earthRadius : earthRadius+wgs84.altitude)
	}

	var  here = this.getRadians();
	var there = that.getRadians();

	var a =
		Math.cos( here.latitude) *
		Math.cos(there.latitude) * 
		Math.pow(Math.sin((there.longitude-here.longitude)/2),2) +
		Math.pow(Math.sin((there.latitude -here.latitude )/2),2) ;

	var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

	// Use average radius
	return (c * (radius(this)+radius(that))/2);
}

// Add heading calculation (of that from this) to GT_WGS84 objects
GT_WGS84.prototype.getHeading=function(that)
{
	var  here = this.getRadians();
	var there = that.getRadians();

	var hdg = Math.atan2(
		Math.sin(there.longitude-here.longitude) * Math.cos(here.latitude) ,
		Math.cos (here.latitude) * Math.sin(there.latitude) -
		Math.sin (here.latitude) * Math.cos(there.latitude) *
		Math.cos(there.longitude-here.longitude));

	// Convert back to degrees
	// 0->360, rather than -180->+180
	hdg*=180/Math.PI;
	if(hdg<0)
		hdg+=360;

	return hdg;
}



// Generic FEED object
// within each type, id must be unique
function FEED(id)
{
//	this.type			=type;
	this.id				=id;
	this.description	="";
	this.name			="";
	this.latestMessage  =null;
	this.earliestMessage=null;
	this.lastUpdated    =null;
	this.tracker		=new Array();
	this.json			={};
	this.getTracker		= function(id)
	{
		for(var fed=0; fed<this.tracker.length; fed++)
		{
			if(this.tracker[fed].id == id)
				return this.tracker[fed];
		}
		return null;
	}	
}
FEED.prototype.onUpdate	= function(){};

function TRACKER()
{
	this.id				= 0;
	this.name			= "";
	this.type			= "";
	this.message		= new Array();
}


// TRACKER_MESSAGE represents a single TRACKER message
// It inherits from GT_WGS84 to give geo (& OSGB) functionality
function TRACKER_MESSAGE()
{
	this.id=null;
	this.type="";
	this.time=0;
	this.battery="";
	this.latitude=0;
	this.longitude=0;
}
TRACKER_MESSAGE.prototype = new GT_WGS84();
TRACKER_MESSAGE.prototype.constructor = TRACKER_MESSAGE;

// method to identify TRACK only type messages
TRACKER_MESSAGE.prototype.isTrack = function()
{
	if("TRACK" == this.type)
		return true;
	return false;
}


// FEEDS is a global array of FEEDs, to allow callbacks
var FEEDS=new Object();
FEEDS.feed=new Array();

// Alphabetic sort on name
FEEDS.sortName = function(a,b)
{
	if(a.name>b.name)
		return 1;
	if(a.name<b.name)
		return -1;
	return 0;
}

// Get the feed object based on the id
FEEDS.getFeed = function(type, feedId)
{
	for(var ix=0; ix<FEEDS.feed.length; ix++)
		if(FEEDS.feed[ix].id == feedId && FEEDS.feed[ix].type == type)
			return FEEDS.feed[ix];
	return null
}

// Add a new FEED
FEEDS.addFeed = function(feed)
{
	FEEDS.feed.push(feed);
	FEEDS.feed.sort(FEEDS.sortName);
}

// Refresh all feeds
FEEDS.refresh = function()
{
	for(var ix=0; ix<FEEDS.feed.length; ix++)
	{
		console.log(FEEDS.feed[ix]);
		FEEDS.feed[ix].update(FEEDS.feed[ix].onUpdate);
	}
}

// vim: ts=2:sw=2
