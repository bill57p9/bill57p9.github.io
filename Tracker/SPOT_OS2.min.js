/////////////////////////////////////////
//                                     //
// ADD METHODS TO SPOT_MESSAGE OBJECTS //
//                                     //
/////////////////////////////////////////
//
// method to identify TRACK only type messages
SPOT_MESSAGE.prototype.isTrack = function()
{
	if("TRACK" == this.type)
		return true;
	return false;
}

// Get earlier data
FEEDS.getHistory=function()
{
// *******************************************************************************
// Should this check for SPOT only???
	for(var ix=0; ix<FEEDS.feed.length; ix++)
		FEEDS.feed[ix].update(FEEDS.feed[ix].onUpdate, null, true);
}

// Display a feed
// Separating this out makes it easier to cope with non-referesh updates
SPOT_FEED.prototype.onUpdate = function(feed)
{
	var insertCell=function(tblRow, html, align)
	{
		if(!align)
			align="right";

		var newCell=tblRow.insertCell(-1);
		newCell.align=align;
		newCell.innerHTML=html;
	};

	// We have a TBODY for each feed, not TRACKER
	var tbody=document.createElement("tbody");

	tbody.innerHTML=
		"<tr><th colspan='5' align='left'>"
		+feed.name+
		"</th></tr>";

	for(var trackerIx=0; trackerIx<feed.tracker.length; trackerIx++)
	{
		var tracker=feed.tracker[trackerIx];
		
		// Define additional variable to store whether to display all tracks
		if(!tracker.trackMsgs)
			tracker.trackMsgs="hide"	// Default: Hide non-latest

		tbody.insertRow(-1).innerHTML=
			"<th colspan='5' align='left'>"
			+tracker.name+
			"</th>";

		// First we count the number of TRACK messages if hiding them
		var trackMsgCount=-1;
		if("hide"==tracker.trackMsgs)
		{
			trackMsgCount=0;
			for(var msgIx=0; msgIx<tracker.message.length; msgIx++)
				if(tracker.message[msgIx].isTrack())
					trackMsgCount++;
		}

		//Messages are already in reverse Chronological order
		for(var msgIx=0; msgIx<tracker.message.length; msgIx++)
		{
			var message=tracker.message[msgIx];

			var osgb=message.getOSGB();

			var row=tbody.insertRow(-1);
			row.title=message.type;

			insertCell(row,DAYS[message.time.getDay()]);
			insertCell(row,message.time.toLocaleTimeString());
			insertCell(row,"<img src='battery_"+message.battery+".png'>");
			insertCell(row,"<a href='http://www.streetmap.co.uk/newprint.srf?x="+
				osgb.eastings+"&y="+osgb.northings+"&z=4&ar=Y'>"+
				osgb.getGridRef(3)+"</a>");

			if(tracker.message.length-1 > msgIx)
			{
				// Reverse chronological order, hence previous in time
				// is next in the array
				var previousMessage=tracker.message[msgIx+1];

				// Speed
				// km/s =           dist(km) /  time(s)
				// km/h = 3600    * dist(km) / (time(ms) / 1000) 
				// km/h = 3600000 * dist(km) / time(ms) 
				insertCell(row,(
					3600000*message.getDistance(previousMessage) /
					(message.time.getTime()-previousMessage.time.getTime())
					).toFixed(1)+" km/h");

				insertCell(row,
					previousMessage.getHeading(message).toFixed(0)
					+" deg");
			}
			else
			{
				row.insertCell(-1);
				row.insertCell(-1);
			}

			if(message.isTrack())
			{
				if("hide"==tracker.trackMsgs)
				{
					if(0==trackMsgCount)
						row.style.display="none";	// Hidden row
					else
					{
						insertCell(row,"TRACK <a href='javascript:FEEDS.trackMsgDisplay(\"SPOT\",\""+feed.id+"\","+trackerIx+",\"show\");'><i>("+(trackMsgCount-1)+" hidden)</i></a>","left");
						trackMsgCount=0;
					}
				}
				else
					insertCell(row,"TRACK <a href='javascript:FEEDS.trackMsgDisplay(\"SPOT\",\""+feed.id+"\","+trackerIx+",\"hide\");'><i>(hide old)</i></a>","left");
			}
			else
				insertCell(row,message.type,"left");
		}
	}

	// Now paste the tbody over the existing TBODY
	var table=document.getElementById("tblMessages");
	if(table.tBodies[feed.id])
		table.tBodies[feed.id].innerHTML=tbody.innerHTML;
	else
	{
		tbody.id=feed.id;
		table.appendChild(tbody);
	}

	// Update the timestamp
	console.log(FEEDS);
	document.getElementById("updateTimestamp").innerHTML=
		FEEDS.feed[0].lastUpdated.toLocaleTimeString() + " " +
		DAYS[FEEDS.feed[0].lastUpdated.getDay()]       + " " +
		FEEDS.feed[0].lastUpdated.toLocaleDateString();

	// Reset the auto update timer
	FEEDS.updateTimer();
}

// This function sets the displayability of the trackMsgs
// hide=hide all bar latest
// show=show all
FEEDS.trackMsgDisplay=function(type, feedId, tracker, trackMsgs)
{
	var feed=FEEDS.getFeed(type, feedId);
	feed.tracker[tracker].trackMsgs=trackMsgs;
	feed.onUpdate(feed);
}

FEEDS.updateTimeout=null;
// This function sets the updateTimer
// based on the menu setting & last update timestamp
FEEDS.updateTimer=function()
{
	// Clear existing timer (if applicable)
	if(FEEDS.updateTimeout)
		clearTimeout(FEEDS.updateTimeout);

	// Get the timer setting
	var timerList=document.getElementById("updateInterval");
	var timeout=timerList.options[timerList.selectedIndex].value;

	if(timeout>0)
	{
		var now=new Date();

		// Timer is specified in minutes. Needs milliseconds
		timeout *= 60000;

		// Now we need to adjust the timeout based on the last update
		// & current time
		timeout -= (now.getTime() - FEEDS.feed[0].lastUpdated.getTime());

		console.log(timeout);

		if(timeout > 0)
			FEEDS.updateTimeout=setTimeout(FEEDS.refresh, timeout);
		else	 // Cover off getting a negative number
			FEEDS.update();
	}
}


////////////////////
//                //
// INITIALISATION //
//                //
////////////////////

// Day of week -> Name conversion
var DAYS=new Array("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");

// Get feed, or use example
var feed=getURLParameter("SPOT");
if (!feed)
	feed = 0;

FEEDS.feed.push(new SPOT_FEED(feed));

// Go get the data!
//FEEDS.refresh();


// Try out LKGPS
function loadDoc() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
		var parser = new DOMParser();
		var responseXML = parser.parseFromString(this.responseText, "text/xml");
		console.log(responseXML);
		console.log(responseXML.getElementsByTagName('b\\:value')[0].childNodes[0].nodeValue);              
     console.log(this.responseText);
    }
  };
//  xhttp.open("GET", "https://anyorigin.com/go/?url=http%3A//www.lkgps.net%3A8080/openapiv3.asmx/GetTracking%3FDeviceID%3D23636%26Model%3D102%26Timezones%3D%26MapType%3D%26Language%3D%26Key%3D7DU2DJFDR8321", true);
//  xhttp.open("GET", "https://whateverorigin.org/get?url=http%3A//www.lkgps.net%3A8080/openapiv3.asmx/GetTracking%3FDeviceID%3D23636%26Model%3D102%26Timezones%3D%26MapType%3D%26Language%3D%26Key%3D7DU2DJFDR8321", true);
  xhttp.open("GET", "sample/GetTracking.xml", true);
  xhttp.send();
}
loadDoc();
//var lkgps=document.createElement("iframe");
//lkgps.src = "http://www.lkgps.net:8080/openapiv3.asmx/GetTracking?DeviceID=23636&Model=102&Timezones=&MapType=&Language=&Key=7DU2DJFDR8321";
//lkgps.onload = function()
//{
//	console.log("loaded")
//	console.log(this.contentDocument.innerHTML);
//};
//document.body.appendChild(lkgps);
//		J50Npi.getJSON("http://www.lkgps.net/Ajax/DevicesAjax.asmx/GetDevicesByUserID?UserID=1546&isFirst=true&TimeZones=China%20Standard%20Time&DeviceID=23636", FEEDS.feed[0].json, function(json)
	//	{
		//	console.log(json);
//		}
//		);



// vim: ts=2:sw=2
